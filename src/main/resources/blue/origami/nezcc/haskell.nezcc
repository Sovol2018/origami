# nezcc file

extension          = hs

# type

Bool               = Bool
Byte               = Word8
Byte[]             = ByteString
Int                = Int
Int64              = Int64
Array              = [%s]
String             = String
Tree               = a
structname         = %s a

TtreeLog           = TreeLog a
Tstate             = Maybe (State a)
#TnewFunc          = @escaping (String,[UInt8],Int,Int,Int) -> Any?
#TsetFunc          = @escaping (Any?,Int,String,Any?) -> Any?

Some               = Just %s
None               = Nothing
None.isEmpty       = (isNothing %s)

Int64->Int         = (fromIntegral %s)
Int->Int64         = (fromIntegral %s)
String->Byte[]     = pack %s
Byte[]->String     = unpack %s

Array.new          = []
Array.size         = (length %s)
Array.get          = (%s !! %s)
Byte[].get         = (%s `index` %s)
Array.slice        = (drop %s (take %s %s))
array              = [
arrays             = ,
end array          = ]

List               = IntMap
List.new           = empty
List.get           = lookup %s %s
List.add           = insert %s %s <targetList>

# syntax

comment          = -- %s
begin            =
end              =
;                =

#module          = module $|base|(parse) where
#end module      =
struct           = data %1$s a = %1$s {%2$s}
record           = %2$s :: %1$s
records          = ,

object           = %1$s {%2$s} 
objectparam      = %1$s=%2$s
objectparams     = , 

getter           = (%2$s %1$s)
setter           = S.put $ %1$s {%2$s = %3$s}

functype         = (%3$s -> S.State (NezParserContext a) %1$s)
functypeparam    = %1$s
functypeparams   = ->
return           = return (%s)

const            = '''
%2$s :: %1$s
%2$s = %3$s
'''

function         = '''
%2$s :: %4$s
%2$s %3$s = do
'''
param    = %2$s
params   =

true             = True
false            = False
null             = Nothing

val              = let %2$s = %3$s
var              = let %2$s = %3$s
assign           = let %s = %s

if               = if (%s) then
else if          = else if (%s) then
switch           = case (%s) of
case             = %s -> %s
default          = _ -> %s

and              = %s && %s
or               = (%s) || (%s)
not              = (not (%s))
ifexpr           = (if (%1$s) then (%2$s) else (%3$s))

funccall         = (S.evalState (%s %s) px')
arg              = (%s)
args             =

lambda           = (\%s -> return (%s))

#base64           = B("%s")
#bools            = B256("%s")

varname           = %s'


MEMOSIZE          = memoSize
MEMOS             = memos

TList             = [(String,a)]
TList.empty       = []
TList.cons        = %s:%s

imports = '''
{-# LANGUAGE FlexibleContexts #-}
module XML(parse) where
import Prelude hiding (length,log)
import Data.Word
import qualified Control.Monad.State as S
import Data.ByteString.Char8 hiding (putStrLn,replicate,take,drop,length)
import Data.Int
import Data.Maybe

'''

def nezvalues = '''
nezvalues :: [ByteString]
nezvalues = [pack data171]

'''

libs = '''
(%) = mod

gettag = (!!) nezsymbols

getlabel = gettag
'''


main = '''

'''

man = '''

'''

#def

setter2          = S.put $ %1$s' {%2$s = %3$s, %4$s = %5$s}

setter3          = S.put $ %1$s' {%2$s = %3$s, %4$s = %5$s, %6$s = %7$s}


def newMemos   = '''
newMemos tree' length' = replicate length' tree'

'''

def getMemo = '''
getMemo :: (NezParserContext a->Int64 -> S.State (NezParserContext a) (MemoEntry a))
getMemo px' key' = do
  return (((memos px') !! (fromIntegral key' % (fromIntegral 257))))

'''

def storeM = '''
storeM :: (NezParserContext a->Int->Int->Bool -> S.State (NezParserContext a) Bool)
storeM px' memoPoint' pos' matched' = do
  let key' = S.evalState (longkey (fromIntegral pos') memoPoint') ()
  let m' = S.evalState (getMemo px' key') ()
  S.put $ m' {key = key', result = if matched' then 1 else 0, mpos = if matched' then pos px' else pos', mtree = tree px'}
  return matched'

'''

def logT = '''
useTreeLog :: (NezParserContext a -> S.State (NezParserContext a) (TreeLog a))
useTreeLog px' = do
  tcur' <-treeLog px'
  if isNothing (lnext tcur') then
    do
      let newtl = TreeLog {lop=0,lpos=0,ltree=Nothing,lprev=(treeLog px'),lnext=Nothing}
      S.put $ px' {treeLog = Just (tcur' {lnext = Just newtl})}
      return $ Just newtl
  else S.put px' >> return $ lnext tcur'

logT :: (NezParserContext a->Int->Int->a -> S.State (NezParserContext a) Bool)
logT px' lop' lpos' tree' = do
  let tcur' = S.evalState (useTreeLog px') ()
  S.put $ px' {treeLog = (tcur' {lop = lop', lpos = lpos', ltree = tree'})}
  return True

'''

def tagT = '''
tagT :: (NezParserContext a->Int -> S.State (NezParserContext a) Bool)
tagT px' ntag' = do
  return (S.evalState (logT px' 1 ntag' (tree px')) px')

'''

def beginT = '''
beginT :: (NezParserContext a->Int -> S.State (NezParserContext a) Bool)
beginT px' shift' = do
  return (S.evalState (logT px' 0 ((pos px') + shift') (tree px')) px')

'''

def backpos = '''
backpos :: (NezParserContext a->Int -> S.State (NezParserContext a) Int)
backpos px' pos'
  | (headpos px') < pos' = do
                           S.put $ px' {headpos = pos'}
                           return pos'
  | otherwise = return pos'

'''


def endT = '''
endT :: NezParserContext a -> Int -> String -> S.State (NezParserContext a) Bool
endT px shift ntag0 = do
  let epos = pos px + shift
  let tcur = treeLog px
  let ntag = ntag0
  let nvalue = 0
  let cnt = 0
  recT cnt ntag nvalue tcur
  where
     recT cnt' ntag' nvalue' tcur' =
       if cnt' == 0
         then rLog tcur' tcur'
         else case (lop tcur' == 3,ntag' == 0 && lop tcur' == 1, nvalue' == 0 && lop tcur' == 2) of
           (True,True,True) -> recT (succ cnt') (lpos tcur') (lpos tcur') (lprev tcur')
           (False,True,True) -> recT cnt' (lpos tcur') (lpos tcur') (lprev tcur')
           (True,False,True) -> recT (succ cnt') ntag' (lpos tcur') (lprev tcur')
           (True,True,False) -> recT (succ cnt') (lpos tcur') nvalue' (lprev tcur')
           (False,False,True) ->recT cnt' ntag' (lpos tcur') (lprev tcur')
           (True,False,False) ->recT (succ cnt') ntag' nvalue' (lprev tcur')
           (False,True,False) ->recT cnt' (lpos tcur') nvalue' (lprev tcur')
           (False,False,False) ->recT cnt' ntag' nvalue' (lprev tcur')
     rLog tcur cnt =
       if lop tcur == 0 then S.put px {treeLog = lprev tcur} >> return True else
         if lop tcur == 3 then {-S.put px {tree = set(tree px) (cnt'-1) (getlabel (lpos tcur')) (ltree tcur')} >>-} rLog (lprev tcur) (cnt - 1)
                          else rLog (lprev tcur) cnt

'''

def parse = '''
parse :: ([Word8]->Int->(String->[Word8]->Int->Int->[(String,a)] -> S.State (NezParserContext a) a) -> S.State (NezParserContext a) a)
parse inputs' length' newFunc' = do
  let tree' = (S.evalState (newFunc' (S.evalState (gettag 0) px') inputs' 0 length' []) px')
  let px' = NezParserContext {inputs=inputs',length=length',pos=0,headpos=0,tree=tree',treeLog=Just (TreeLog {lop=0,lpos=0,ltree=tree',lprev=Nothing,lnext=Nothing}),newFunc=(if (newFunc' == Nothing) then (newAST) else (newFunc')),state=Nothing,memos=(S.evalState (newMemos tree' 257) px')}
  let tree' = (if ((S.evalState (e0 px') px')) then ((tree px')) else ((S.evalState (newFunc' (S.evalState (gettag nezerror) px') inputs' (headpos px') length' []) px')))
  return (tree')


'''

def newAST2 = '''
newAST tag inputs pos epos 0 = [(tag, (take pos (drop epos) inputs))]
newAST tag inputs pos epos _ = [([], [])]--ok???

subAST parent n label child = parent
'''