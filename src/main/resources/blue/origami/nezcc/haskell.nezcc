# nezcc file

extension          = hs

# type

Bool               = Bool
Byte               = Word8
Byte[]             = [Word8]
Int                = Int
Int64              = Int64
Array              = [%s]
String             = String
Tree               = a
structname         = %s a

TtreeLog           = Maybe (TreeLog a)
Tstate             = Maybe (State a)
#TnewFunc          = @escaping (String,[UInt8],Int,Int,Int) -> Any?
#TsetFunc          = @escaping (Any?,Int,String,Any?) -> Any?

Some               = Just %s
None               = Nothing
None.isEmpty       = (isNothing %s)

Int64->Int         = (fromIntegral %s)
Int->Int64         = (fromIntegral %s)
String->Byte[]     = pack %s
Byte[]->String     = unpack %s

Array.new          = []
Array.size         = (length %s)
Array.get          = (%s !! %s)
Array.slice        = (drop %s (take %s %s))
array              = [
arrays             = ,
end array          = ]

List               = IntMap
List.new           = empty
List.get           = lookup %s %s
List.add           = insert %s %s <targetList>

# syntax

comment          = -- %s
begin            =
end              =
;                =

#module          = module $|base|(parse) where
#end module      =
struct           =
record           = _%2$s :: %1$s
records          = ,

object           = %1$s {%2$s} 
objectparam      = _%1$s=%2$s
objectparams     = , 

getter           = ((view [l| _%2$s|]) %1$s)
setter           = S.put $ (set [l| _%2$s|]) %3$s %1$s

functype         = (%3$s -> S.State (NezParserContext a) %1$s)
functypeparam    = %1$s
functypeparams   = ->
return           = return %s

const            = '''
%2$s :: %1$s
%2$s = %3$s
'''

function         = '''
--%2$s :: %4$s
%2$s %3$s = do
'''
param    = %2$s
params   =

true             = True
false            = False
null             = Nothing

val              = let %2$s = %3$s
var              = let %2$s = %3$s
assign           = let %s = %s

if               = if (%s) then
else if          = else if (%s) then
switch           = case (%s) of
case             = %s -> %s
default          = _ -> %s

and              = %s && %s
or               = (%s) || (%s)
not              = (not (%s))
ifexpr           = (if (%1$s) then (%2$s) else (%3$s))

funccall         = ((%s %s) >>= fst)
arg              = (%s)
args             =

lambda           = (\%s -> %s)

#base64           = B("%s")
#bools            = B256("%s")

varname           = %s'


MEMOSIZE          = memoSize
MEMOS             = memos

TList             = [(String,a)]
TList.empty       = []
TList.cons        = %s:%s

imports = '''
{-# LANGUAGE QuasiQuotes #-}

module XML(parse) where
import Prelude hiding (length,log)
import Data.Word
import qualified Control.Monad.State as S
import Data.ByteString hiding (putStrLn,replicate,take,drop,length)
import Data.Int
import Record


'''

libs = '''
(%) = mod

produce :: a -> (a -> b) -> b
produce a f = f a

'''


main = '''

'''

man = '''

'''

#def

setter2          = S.put $ foldl produce %1$s [set [l| %2$s|] %3$s, set [l| %4$s|] %5$s]

setter3          = S.put $ foldl produce %1$s [set [l| %2$s|] %3$s, set [l| %4$s|] %5$s, set [l| %6$s|] %7$s]

def storeM = '''
--storeM :: (NezParserContext a->Int->Int->Bool -> Bool)
storeM px' memoPoint' pos' matched' = do
  let key' = ((longkey (fromIntegral pos') memoPoint') >>= fst)
  let m' = ((getMemo px' key') >>= fst)
  S.put $ foldl produce m' [set [l| _key|] key'
                          , set [l| _result|] (if (matched') then (1) else (0))
                          , set [l| _pos|] (if (matched') then (pos px') else (pos'))
                          , set [l| _tree|] (view [l| tree|] px')
                          ]
  return matched'

'''


def newMemos   = '''
type TreeLog a = [r| {_op :: Int, _log :: Int, _tree :: a, _prevLog :: Maybe (TreeLog a), _nextLog :: Maybe (TreeLog a)} |]

type State a = [r| {_ntag :: Int, _cnt :: Int, _value :: [Word8], _prevState :: Maybe (State a)} |]

type MemoEntry a = [r| {_key :: Int64, _result :: Int, _pos :: Int, _tree :: a, _state :: Maybe (State a)} |]

type NezParserContext a = [r| {_inputs :: [Word8], _length :: Int, _pos :: Int, _headpos :: Int, _tree :: a, _treeLog :: Maybe (TreeLog a), _newFunc :: String->ByteString->Int->Int->[(String,a)] -> a, _state :: Maybe (State a), _memos :: [MemoEntry a]} |]

newMemos tree' length' = replicate length' tree'

'''

def logT = '''
logT px' op' log' tree' = do
  treelog <- useTreeLog px'
  let tcur' = fst treelog
  let pxx' = snd treelog
  let newpx = foldl produce tcur' [set [l| _op|] op', set [l| _log|] log', set [l| _tree|] tree']
  S.put $ set [l| _treeLog|] newpx pxx'
  return (True)

useTreeLog px' = do
  let tcur' = view [l| _treeLog|] px'
  if isNothing (view [l| _nextLog|] tcur') then do
    let tree' = view [l| _tree|] px'
    let prevLog' = view [l|_treeLog|] px'
    let nextlog' = Just [r| {_op=0
                           , _log=0
                           , _tree= tree'
                           , _prevLog= prevLog'
                           , _nextLog=Nothing}|]
    S.put $ set [l| _nextLog|] nextlog' tcur'
    return $ view [l| _nextLog|] tcur'
  else
    return $ view [l| _nextLog|] tcur'

'''


def AST = '''
data AST = AST String String AST
         | Notree
         deriving (Show)

'''

def newAST = '''
newAST tag inputs pos epos 0 = [(tag, (take pos (drop epos) inputs))]
newAST tag inputs pos epos _ = AST [] Notree

'''

def subAST = '''
subAST parent n label child = parent

'''

def newAST2 = '''
newAST tag inputs pos epos 0 = AST tag (take pos (drop epos) inputs) Notree
newAST tag inputs pos epos _ = AST [] Notree
'''

