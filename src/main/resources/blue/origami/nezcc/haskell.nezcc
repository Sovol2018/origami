# nezcc file

extension          = hs

# type

Bool               = Bool
Byte               = Word8
Byte[]             = [Word8]
Int                = Int
Int64              = Int64
Array              = [%s]
String             = String
Tree               = a
structname         = %s a

TtreeLog           = Maybe (TreeLog a)
Tstate             = Maybe (State a)
#TnewFunc          = @escaping (String,[UInt8],Int,Int,Int) -> Any?
#TsetFunc          = @escaping (Any?,Int,String,Any?) -> Any?

Some               = Just %s
None               = Nothing
None.isEmpty       = (isNothing %s)

Int64->Int         = (fromIntegral %s)
Int->Int64         = (fromIntegral %s)
String->Byte[]     = pack %s
Byte[]->String     = unpack %s

Array.new          = []
Array.size         = (length %s)
Array.get          = (%s !! %s)
Array.slice        = (drop %s (take %s %s))
array              = [
arrays             = ,
end array          = ]

List               = IntMap
List.new           = empty
List.get           = lookup %s %s
List.add           = insert %s %s <targetList>

# syntax

comment          = -- %s
begin            =
end              =
;                =

#module          = module $|base|(parse) where
#end module      =
struct           =
record           = _%2$s :: %1$s
records          = ,

object           = %1$s {%2$s} 
objectparam      = _%1$s=%2$s
objectparams     = , 

getter           = (#_%2$s %1$s)
setter           = S.put $ %1$s {_%2$s = %3$s}

functype         = (%3$s -> %1$s)
functypeparam    = %1$s
functypeparams   = ->
return           = return %s

const            = '''
%2$s :: %1$s
%2$s = %3$s
'''

function         = '''
--%2$s :: %4$s
%2$s %3$s = do
'''
param    = %2$s
params   =

true             = True
false            = False
null             = Nothing

val              = let %2$s = %3$s
var              = let %2$s = %3$s
assign           = let %s = %s

if               = if (%s) then
else if          = else if (%s) then
switch           = case (%s) of
case             = %s -> %s
default          = _ -> %s

and              = %s && %s
or               = (%s) || (%s)
not              = (not (%s))
ifexpr           = (if (%1$s) then (%2$s) else (%3$s))

funccall         = ((%s %s) >>= fst)
arg              = (%s)
args             =

lambda           = (\%s -> %s)

#base64           = B("%s")
#bools            = B256("%s")

varname           = %s'


MEMOSIZE          = memoSize
MEMOS             = memos

TList             = [(String,a)]
TList.empty       = []
TList.cons        = %s:%s

imports = '''
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE OverloadedLabels #-}
{-# LANGUAGE DataKinds, TypeFamilies #-}
{-# LANGUAGE FlexibleInstances, MultiParamTypeClasses #-}
--{-# LANGUAGE TemplateHaskell #-}

module Math(parse) where
import Prelude hiding (length,log)
import GHC.OverloadedLabels
import Data.Word
--import Lens.Labels hiding ((.))
--import Control.Lens (makeLenses)
import qualified Control.Monad.State as S
import Data.ByteString hiding (putStrLn,replicate,take,drop,length)
import Data.Int
--import Data.ByteString.Short
--import Data.IntMap (IntMap)


'''

libs = '''
(%) = mod

'''


main = '''

'''

man = '''

'''

#def

setter2          = S.put $ %1$s {_%2$s = %3$s, _%4$s = %5$s}

setter3          = S.put $ %1$s {_%2$s = %3$s, _%4$s = %5$s, _%6$s = %7$s}

def storeM = '''
--storeM :: (NezParserContext a->Int->Int->Bool -> Bool)
storeM px' memoPoint' pos' matched' = do
  let key' = ((longkey (fromIntegral pos') memoPoint') >>= fst)
  let m' = ((getMemo px' key') >>= fst)
  S.put $ m' {_key = key'
            , _result = (if (matched') then (1) else (0))
            , _pos = if (matched') then (pos px') else (pos')
            , _tree = get tree px'}
  return matched'

'''


def newMemos   = '''
data TreeLog a = TreeLog {_op :: Int
                        , _log :: Int
                        , _tree :: a
                        , _prevLog :: Maybe (TreeLog a)
                        , _nextLog :: Maybe (TreeLog a)}
                        deriving(Show)

instance (a ~ Int) => IsLabel "_op" (TreeLog b -> a) where
  fromLabel _ (TreeLog p q r s t) = p

instance (a ~ Int) => IsLabel "_log" (TreeLog b -> a) where
  fromLabel _ (TreeLog p q r s t) = q

instance (a ~ b) => IsLabel "_tree" (TreeLog b -> a) where
  fromLabel _ (TreeLog p q r s t) = r

instance (a ~ Maybe (TreeLog b)) => IsLabel "_prevLog" (TreeLog b -> a) where
  fromLabel _ (TreeLog p q r s t) = s

instance (a ~ Maybe (TreeLog b)) => IsLabel "_nextLog" (TreeLog b -> a) where
  fromLabel _ (TreeLog p q r s t) = t


data State a = State {_ntag :: Int
                    , _cnt :: Int
                    , _value :: [Word8]
                    , _prevState :: Maybe (State a)}
                    deriving(Show)

instance (a ~ Int) => IsLabel "_ntag" (State b -> a) where
  fromLabel _ (State p q r s) = p

instance (a ~ Int) => IsLabel "_cnt" (State b -> a) where
  fromLabel _ (State p q r s) = q

instance (a ~ [Word8]) => IsLabel "_value" (State b -> a) where
  fromLabel _ (State p q r s) = r

instance (a ~ Maybe (State b)) => IsLabel "_prevState" (State b -> a) where
  fromLabel _ (State p q r s) = s

data MemoEntry a = MemoEntry {_key :: Int64
                            , _result :: Int
                            , _pos :: Int
                            , _tree :: a
                            , _state :: Maybe (State a)}
                            deriving(Show)

instance (a ~ Int64) => IsLabel "_key" (MemoEntry b -> a) where
  fromLabel _ (MemoEntry p q r s t) = p

instance (a ~ Int) => IsLabel "_result" (MemoEntry b -> a) where
  fromLabel _ (MemoEntry p q r s t) = q

instance (a ~ Int) => IsLabel "_pos" (MemoEntry b -> a) where
  fromLabel _ (MemoEntry p q r s t) = r

instance (a ~ b) => IsLabel "_tree" (MemoEntry b -> a) where
  fromLabel _ (MemoEntry p q r s t) = s

instance (a ~ Maybe (State b)) => IsLabel "_state" (MemoEntry b -> a) where
  fromLabel _ (MemoEntry p q r s t) = t

data NezParserContext a = NezParserContext {_inputs :: [Word8]
                                          , _length :: Int
                                          , _pos :: Int
                                          , _headpos :: Int
                                          , _tree :: a
                                          , _treeLog :: Maybe (TreeLog a)
                                          , _newFunc :: String->ByteString->Int->Int->[(String,a)] -> a
                                          , _state :: Maybe (State a)
                                          , _memos :: [MemoEntry a]}

instance (a ~ [Word8]) => IsLabel "_inputs" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = p

instance (a ~ Int) => IsLabel "_length" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = q

instance (a ~ Int) => IsLabel "_pos" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = r

instance (a ~ Int) => IsLabel "_headpos" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = s

instance (a ~ b) => IsLabel "_tree" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = t

instance (a ~ Maybe (TreeLog b)) => IsLabel "_treeLog" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = u

instance (a ~ (String->ByteString->Int->Int->[(String,b)] -> b)) => IsLabel "_newFunc" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = v

instance (a ~ Maybe (State b)) => IsLabel "_state" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = w

instance (a ~ [MemoEntry b]) => IsLabel "_memos" (NezParserContext b -> a) where
  fromLabel _ (NezParserContext p q r s t u v w x) = x

newMemos tree' length' = replicate length' tree'

'''

def logT = '''
logT px' op' log' tree' = do
  treelog <- useTreeLog px'
  let tcur' = fst treelog
  let pxx' = snd treelog
  let newpx = tcur' {_op = op', _log = log', _tree = tree'}
  S.put $ pxx' {_treeLog = newpx}
  return (True)

useTreeLog px' = do
  let tcur' = #_treeLog px'
  if isNothing (#_nextLog tcur') then do
    S.put $ tcur'{_nextLog = Just TreeLog {_op=0,_log=0,_tree= #_tree px',_prevLog= #_treeLog px',_nextLog=Nothing}}
    return $ #_nextLog tcur'
  else
    return $ #_nextLog tcur'

'''

def AST = '''
data AST = AST String String AST
         | Notree
         deriving (Show)

'''

def newAST = '''
newAST tag inputs pos epos 0 = [(tag, (take pos (drop epos) inputs))]
newAST tag inputs pos epos _ = AST [] Notree

'''

def subAST = '''
subAST parent n label child = parent

'''

def newAST2 = '''
newAST tag inputs pos epos 0 = AST tag (take pos (drop epos) inputs) Notree
newAST tag inputs pos epos _ = AST [] Notree
'''

def parse = '''
parse inputs' length' newFunc' = do
  let tree' = ((newFunc' ((gettag 0) >>= fst) inputs' 0 length' []) >>= fst)
  let px' = NezParserContext {_inputs=inputs'
                            , _length=length'
                            , _pos=0
                            , _headpos=0
                            , _tree=tree'
                            , _treeLog=Just TreeLog {_op=0,_log=0,_tree=tree',_prevLog=Nothing,_nextLog=Nothing}
                            , _newFunc= if (isNothing newFunc') then newAST else newFunc'
                            , _state=Nothing
                            , _memos=((newMemos tree' 257) >>= fst)}
  let tree' = (if ((e0 px') >>= fst) then (#_tree px') else (((newFunc' ((gettag nezerror) >>= fst) inputs' (#_headpos px') length' []) >>= fst)))
  return tree'
'''